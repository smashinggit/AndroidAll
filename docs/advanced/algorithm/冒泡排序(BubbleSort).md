[toc]





# 写在前面：如何分析一个"排序算法"



## 1、排序算法的执行效率



###  最好情况、最坏情况、平均情况时间复杂度



在分析排序算法的时间复杂度时，要分别给出最好情况、最坏情况、平均情况下的时间复杂度。
对于要排序的数据，有的接近有序，有的完全无序。有序度不同的数据，对于排序的执行时间肯定是有影响的

所以我们要知道排序算法在不同数据下的性能表现



### 时间复杂度的系数、常数 、低阶



>  **时间复杂度反映的是数据规模 n 很大的时候的一个增长趋势，所以它表示的时候会忽略系数、常数、低阶**

但是实际的软件开发中，我们排序的可能是 10 个、100 个、1000 个这样规模很小的数据，
所以，在对同一阶时间复杂度的排序算法性能对比的时候，我们就要把系数、常数、低阶也考虑进来



###  比较次数和交换（或移动）次数

有一部分算法是基于比较的排序算法，基于比较的排序算法的执行过程，
会涉及两种操作，一种是元素比较大小，另一种是元素交换或移动。

所以，如果我们在分析排序算法的执行效率的时候，应该把比较次数和交换（或移动）次数也考虑进去



## 2、排序算法的内存消耗



算法的内存消耗可以通过空间复杂度来衡量，排序算法也不例外。
不过，针对排序算法的空间复杂度，我们还引入了一个新的概念，原地排序（Sorted in place）

**原地排序算法，就是特指空间复杂度是 O(1) 的排序算法**



## 3、排序算法的稳定性

仅仅用执行效率和内存消耗来衡量排序算法的好坏是不够的。
针对排序算法，我们还有一个重要的度量指标，稳定性。这个概念是说，**如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变**

比如我们有一组数据 2，9，3，4，8，3，按照大小排序之后就是 2，3，3，4，8，9。

这组数据里有两个 3。经过某种排序算法排序之后，

- 如果两个 3 的前后顺序没有改变，那我们就把这种排序算法叫作**稳定的排序算法**

- 如果前后顺序发生变化，那对应的排序算法就叫作**不稳定的排序算法**

  

你可能要问了，两个 3 哪个在前，哪个在后有什么关系啊，稳不稳定又有什么关系呢？为什么要考察排序算法的稳定性呢？

在讲排序的时候，都是用整数来举例，但在**真正软件开发中，我们要排序的往往不是单纯的整数，而是一组对象**，我们需要按照对象的某个 key 来排序，当某个key一样的时候，排序后相同key的元素有没有进行位置交换完全不同的情况

**稳定排序算法可以保持某个key相同的两个对象，在排序之后的前后顺序不变**

# 一、冒泡排序



冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求。如果不满足就让它俩互换。
**一次冒泡会让至少一个元素移动到它应该在的位置**，重复 n 次，就完成了 n 个数据的排序工作





```
public class BubbleSort {
    private static final int[] data = {2, 5, 4, 1, 6, 3};

    public static void main(String[] args) {
        int[] sortedData = bubbleSort(data);
    }

    public static int[] bubbleSort(int[] data) {
        System.out.println("排序前：" + Arrays.toString(data));

        // 因为每次对两个数据进行比较，所以只需要  data.length - 1 次排序
        // 即当 data.length - 1 个数据已经排好位置了，剩下的一个数据自然就在自己改在的位置上
        for (int i = 0; i < data.length - 1; i++) {

            // 每进行一次循环，都会让至少一个元素移动到它应该在的位置
            // 因为每进行一次排序，都会让有序数据下沉到数组最后，所以这里的条件是 data.length - 1 - i,
            // 即 不对最后已经排过序的数据进行比较
            for (int j = 0; j < data.length - 1 - i; j++) {
                if (data[j] > data[j + 1]) {
                    int temp = data[j + 1];
                    data[j + 1] = data[j];
                    data[j] = temp;
                }
            }
            System.out.println("第 " + (i + 1) + " 次排序：" + Arrays.toString(data));
        }

        System.out.println("排序后：" + Arrays.toString(data));
        return data;
    }
}
```



输出如下：

```
排序前：[2, 5, 4, 1, 6, 3]
第 1 次排序：[2, 4, 1, 5, 3, 6]
第 2 次排序：[2, 1, 4, 3, 5, 6]
第 3 次排序：[1, 2, 3, 4, 5, 6]
第 4 次排序：[1, 2, 3, 4, 5, 6]
第 5 次排序：[1, 2, 3, 4, 5, 6]
排序后：[1, 2, 3, 4, 5, 6]
```

# 二、冒泡排序的优化



通过上面的输出我们可以看到，第3次排序的时候就数组就已经排好顺序了，这时就没有必要再进行后面的排序了。

也就是说，**当某次冒泡操作已经没有数据交换时，说明已经达到完全有序，不用再继续执行后续的冒泡操作**

我们可以通过一个标志位来判断，如果没有数据交换，就提前退出循环。



优化后的代码如下：

```
public class BubbleSort {
    private static final int[] data = {2, 5, 4, 1, 6, 3};

    public static void main(String[] args) {
        int[] sortedData = bubbleSort(data);
    }

    public static int[] bubbleSort(int[] data) {
        System.out.println("排序前：" + Arrays.toString(data));

        if (data == null || data.length < 2) {
            return data;
        }

        // 因为每次对两个数据进行比较，所以只需要  data.length - 1 次排序
        // 即当 data.length - 1 个数据已经排好位置了，剩下的一个数据自然就在自己改在的位置上
        for (int i = 0; i < data.length - 1; i++) {

            // 提前退出冒泡循环的标志位
            boolean flag = false;

            // 每进行一次循环，都会让至少一个元素移动到它应该在的位置
            // 因为每进行一次排序，都会让有序数据下沉到数组最后，所以这里的条件是 data.length - 1 - i,
            // 即 不对最后已经排过序的数据进行比较
            for (int j = 0; j < data.length - 1 - i; j++) {
                if (data[j] > data[j + 1]) {
                    int temp = data[j + 1];
                    data[j + 1] = data[j];
                    data[j] = temp;

                    flag = true;  //表示有数据交换
                }
            }
            System.out.println("第 " + (i + 1) + " 次排序：" + Arrays.toString(data));

            if (!flag) {  // 没有数据交换，提前退出
                System.out.println("排序完成，提前退出");
                break;
            }
        }

        System.out.println("排序后：" + Arrays.toString(data));
        return data;
    }
}
```



输出如下：

```
排序前：[2, 5, 4, 1, 6, 3]
第 1 次排序：[2, 4, 1, 5, 3, 6]
第 2 次排序：[2, 1, 4, 3, 5, 6]
第 3 次排序：[1, 2, 3, 4, 5, 6]
第 4 次排序：[1, 2, 3, 4, 5, 6]
排序完成，提前退出
排序后：[1, 2, 3, 4, 5, 6]
```



通过输出可以看到，我们在第3次的时候就已经完成了数据的排序，但是由于在第3次排序的时候还是进行了数据交换，所以没有走到提前退出的代码。

当进行第4次排序的时候，由于数据已经是有序的了，没有进行数据交互，所以提前退出，不再进行后面的操作





# 三、冒泡排序的性能分析



## 时间复杂度

- **最好情况时间复杂度是 O(n)**

   最好情况下，要排序的数据已经是有序的了，我们只需要进行一次冒泡操作，就可以结束了，所以最好情况时间复杂度是 O(n)。

- **坏情况时间复杂度为 O(n2)**

  最坏的情况是，要排序的数据刚好是倒序排列的，我们需要进行 n 次冒泡操作，所以最坏情况时间复杂度为 O(n2)

- **平均情况下的时间复杂度就是 O(n2)**

  

  

## 内存消耗



冒泡的过程只涉及相邻数据的交换操作，只需要常量级的临时空间，所以它的**空间复杂度为 O(1)，是一个原地排序算法**



## 稳定性

在冒泡排序中，只有交换才可以改变两个元素的前后顺序。
为了保证冒泡排序算法的稳定性，当有相邻的两个元素大小相等的时候，我们不做交换，相同大小的数据在排序前后不会改变顺序，所以**冒泡排序是稳定的排序算法**

[toc]
[https://github.com/ddnosh/BestReview#Java](https://github.com/ddnosh/BestReview#Java)

# 一、进制及相互转换

## 概念

二进制：由0，1组成，运算规律是逢二进一，计算机只能识别二进制表示的数据；
八进制：由0、1、2、3、4、5、6、7组成，运算规律是逢八进一；
十进制：由0，1，2、3、4、5、6、7、8、9组成，运算规律是逢十进一；
十六进制：由数字0～9以及字母A，B，C，D，E，F组成，运算规律是逢十六进一；

## 声明
在 Java 中，
- 二进制变量的声明以0b为前缀             Binary system，简写BIN
- 八进制变量的声明以0为前缀              Octal number system，简写OCT
- 十进制没有前缀                        Decimal system，简写DEC
- 十六进制变量的声明以0x为前缀           Hexadecimal，简写HEX


**二进制、八进制、十六进制数值在运用时候自动转为对应的十进制的值**
例如声明变量 int a = 0b11 , 在使用变量 a 时，它的值就是 3


## 转换

十进制转其他进制：
- 二进制：Integer.toBinaryString(i);
- 八进制：Integer.toOctalString(i);
- 十六进制：Integer.toHexString(i);


其他进制转十进制：
- "二进制0b10001转十进制 " + Integer.valueOf("10001", 2);   //17
- "八进制021转十进制 " + Integer.valueOf("21", 8);          //17
- "十六进制0x11转十进制 " + Integer.valueOf("11", 16);       //17

或者

- "二进制0b10001转十进制 " + Integer.parseInt("10001", 2);   //17
- "八进制021转十进制 " + Integer.parseInt("21", 8);          //17
- "十六进制0x11转十进制 " + Integer.parseInt("11", 16);       //17


# 二、计算机中的存储单位：bit
在计算机的二进制数系统中，位简记为bit，也称为比特，是数据存储的最小单位，
每个二进制数字0或1就是一个位(bit)，也就是一比特
8 bit（位）= 1B，也就是一个字节（Byte）

1B = 8 bit
1KB（Kibibyte，千字节）= 1024B = 2^10 B
1MB（Mebibyte，兆字节，百万字节，简称“兆”）= 1024KB = 2^20 B
1GB（Gigabyte，吉字节，十亿字节，又称“千兆”）= 1024MB = 2^30 B
1TB（Terabyte，万亿字节，太字节）= 1024GB = 2^40 B
1PB（Petabyte，千万亿字节，拍字节）= 1024TB = 2^50 B


# 三、原码、反码、补码
(https://zhuanlan.zhihu.com/p/91967268)[https://zhuanlan.zhihu.com/p/91967268]

## 概念
计算机底层均是以二进制表示的，数字也不例外
有符号数（这里的符号指的是正负符号，有符号数指的就是正负数）有3种表示法：
**原码、反码和补码**，所有数据的运算都是采用**补码**进行的

- 原码 ：最高位为符号位，0代表正数，1代表负数，非符号位为该数字绝对值的二进制表示
         因为第一位是符号位，所以8位二进制数的取值范围就是：
         [1111 1111 , 0111 1111] 即 [-127 , 127]

如： 127  的原码为 0111 1111     
    -127  的原码为 1111 1111
    
- 反码 ：正数的反码与原码一致
        负数的反码是对原码按位取反，只是最高位(符号位)不变    
           
如： 127 的反码为 0111 1111
    -127 的反码为 1000 0000
    
- 补码 ： 正数的补码与原码一致
          负数的补码是该数的**反码加1**
          
如： 127 的补码为 0111 1111
    -127 的补码为 1000 0001          
          
总结：
**1. 正数的原码，反码，补码都相同** 
**2. 负数的反码是对原码按位取反，补码是反码加1**

## 为什么用补码进行计算
如果计算机内部采用原码来表示数，那么在进行加法和减法运算的时候，需要转化为两个绝对值的加法和减法运算
于是人们开始探索将符号位参与运算，并且只保留加法的方法。



# TCP和UDP的区别：
TCP 提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接
UDP 在传送数据之前不需要先建立连接，远地主机在收到 UDP 报文后，不需要给出任何确认。
虽然 UDP 不提供可靠交付，但在某些情况下 UDP 确是一种最有效的工作方式（一般用于即时通信），比如： QQ 语音、 QQ 视频 、直播等等

1. TCP面向连接，UDP无连接
2. TCP面向字节流（文件传输），
   UDP是面向报文的，UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对IP电话，实时视频会议等）
3. TCP首部开销20字节，UDP的首部开销小，只有8个字节
4. TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;
   UDP尽最大努力交付，即不保证可靠交付   
5. 每一条TCP连接只能是点到点的；UDP支持一对一，一对多，多对一和多对多的交互通信   
6. TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道


# HTTP和HTTPS的区别
  HTTP协议时超文本传输协议
  HTTPS是安全的超文本传输协议，是安全版的HTTP协议，使用安全套接字层(SSL)进行信息交换
  
HTTPS协议主要针对解决HTTP协议以下不足：
1. 通信使用明文（不加密），内容可能会被窃听
2. 不验证通信方身份，应此可能遭遇伪装
3. 无法证明报文的完整性（即准确性），所以可能已遭篡改

> HTTP+加密+认证+完整性保护=HTTPS

HTTP端口 80
HTTPS端口 443


# TCP 三次握手和四次挥手

## 三次握手

1. 客户端– 发送带有 SYN 标志的数据包–      一次握手–服务端
2. 服务端– 发送带有 SYN/ACK 标志的数据包–  二次握手–客户端
3. 客户端– 发送带有带有 ACK 标志的数据包–   三次握手–服务端

## 为什么要三次握手
三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，
而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。

第一次握手：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常
第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常
第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常

所以三次握手就能确认双发收发功能都正常，缺一不可。



## 四次挥手

客户端-发送一个 FIN，用来关闭客户端到服务器的数据传送
服务器-收到这个 FIN，它发回一 个 ACK，确认序号为收到的序号加1 。和 SYN 一样，一个 FIN 将占用一个序号
服务器-关闭与客户端的连接，发送一个FIN给客户端
客户端-发回 ACK 报文确认，并将确认序号设置为收到序号加1

任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。
当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。

举个例子：A 和 B 打电话，通话即将结束后，A 说“我没啥要说的了”，B回答“我知道了”，
但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话，于是 B 可能又巴拉巴拉说了一通，
最后 B 说“我说完了”，A 回答“知道了”，这样通话才算结束。

# Cookie的作用是什么?和Session有什么区别

Cookie 和 Session都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太一样。
Cookie 数据保存在客户端(浏览器端)，
Session 数据保存在服务器端。

# URI和URL的区别是什么
- URI(Uniform Resource Identifier) 是统一资源标志符，可以唯一标识一个资源。
- URL(Uniform Resource Location) 是统一资源定位符，可以提供该资源的路径。
它是一种具体的 URI，即 URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源

URI的作用像身份证号一样，
URL的作用更像家庭住址一样。URL是一种具体的URI，它不仅唯一标识资源，而且还提供了定位该资源的信息。

# 对称加密、非对称加密

- 对称加密：密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的对称加密算法有DES、AES等
- 非对称加密：密钥成对出现（且根据公钥无法推知私钥，根据私钥也无法推知公钥），
加密解密使用不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢，
典型的非对称加密算法有RSA、DSA等














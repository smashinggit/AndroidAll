[toc]
[https://github.com/ddnosh/BestReview#Java](https://github.com/ddnosh/BestReview#Java)

# 一、进制及相互转换

## 概念

二进制：由0，1组成，运算规律是逢二进一，计算机只能识别二进制表示的数据；
八进制：由0、1、2、3、4、5、6、7组成，运算规律是逢八进一；
十进制：由0，1，2、3、4、5、6、7、8、9组成，运算规律是逢十进一；
十六进制：由数字0～9以及字母A，B，C，D，E，F组成，运算规律是逢十六进一；

## 声明
在 Java 中，
- 二进制变量的声明以0b为前缀             Binary system，简写BIN
- 八进制变量的声明以0为前缀              Octal number system，简写OCT
- 十进制没有前缀                        Decimal system，简写DEC
- 十六进制变量的声明以0x为前缀           Hexadecimal，简写HEX


**二进制、八进制、十六进制数值在运用时候自动转为对应的十进制的值**
例如声明变量 int a = 0b11 , 在使用变量 a 时，它的值就是 3


## 转换

十进制转其他进制：
- 二进制：Integer.toBinaryString(i);
- 八进制：Integer.toOctalString(i);
- 十六进制：Integer.toHexString(i);


其他进制转十进制：
- "二进制0b10001转十进制 " + Integer.valueOf("10001", 2);   //17
- "八进制021转十进制 " + Integer.valueOf("21", 8);          //17
- "十六进制0x11转十进制 " + Integer.valueOf("11", 16);       //17

或者

- "二进制0b10001转十进制 " + Integer.parseInt("10001", 2);   //17
- "八进制021转十进制 " + Integer.parseInt("21", 8);          //17
- "十六进制0x11转十进制 " + Integer.parseInt("11", 16);       //17


# 二、计算机中的存储单位：bit
在计算机的二进制数系统中，位简记为bit，也称为比特，是数据存储的最小单位，
每个二进制数字0或1就是一个位(bit)，也就是一比特
8 bit（位）= 1B，也就是一个字节（Byte）

1B = 8 bit
1KB（Kibibyte，千字节）= 1024B = 2^10 B
1MB（Mebibyte，兆字节，百万字节，简称“兆”）= 1024KB = 2^20 B
1GB（Gigabyte，吉字节，十亿字节，又称“千兆”）= 1024MB = 2^30 B
1TB（Terabyte，万亿字节，太字节）= 1024GB = 2^40 B
1PB（Petabyte，千万亿字节，拍字节）= 1024TB = 2^50 B


# 三、原码、反码、补码
(https://zhuanlan.zhihu.com/p/91967268)[https://zhuanlan.zhihu.com/p/91967268]

## 概念
计算机底层均是以二进制表示的，数字也不例外
有符号数（这里的符号指的是正负符号，有符号数指的就是正负数）有3种表示法：
**原码、反码和补码**，所有数据的运算都是采用**补码**进行的

- 原码 ：最高位为符号位，0代表正数，1代表负数，非符号位为该数字绝对值的二进制表示
         因为第一位是符号位，所以8位二进制数的取值范围就是：
         [1111 1111 , 0111 1111] 即 [-127 , 127]

如： 127  的原码为 0111 1111     
    -127  的原码为 1111 1111
    
- 反码 ：正数的反码与原码一致
         负数的反码是对原码按位取反，只是最高位(符号位)不变    
           
如： 127 的反码为 0111 1111
    -127 的反码为 1000 0000
    
- 补码 ： 正数的补码与原码一致
          负数的补码是该数的**反码加1**
          
如： 127 的补码为 0111 1111
    -127 的补码为 1000 0001          
          
总结：
**1. 正数的原码，反码，补码都相同** 
**2. 负数的反码是对原码按位取反，补码是反码加1**

## 为什么用补码进行计算
如果计算机内部采用原码来表示数，那么在进行加法和减法运算的时候，需要转化为两个绝对值的加法和减法运算
于是人们开始探索将符号位参与运算，并且只保留加法的方法。






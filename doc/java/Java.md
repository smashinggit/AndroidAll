[toc]

# 一、基本数据类型

- byte:  8位、有符号的，以二进制补码表示的整数,最小值是 -128（-2^7）,最大值是 127（2^7-1）,默认值为0

         byte 类型用在大型数组中节约空间，主要代替整数，
         因为 byte 变量占用的空间只有 int 类型的四分之一
         例子：byte a = 100，byte b = -50

- short：16位，有符号的，以二进制补码表示的整数，最小值是 -32768（-2^15），最大值是 32767（2^15 - 1）,默认值为0

         Short 数据类型也可以像 byte 那样节省空间。一个short变量是int型变量所占空间的二分之一
         例子：short s = 1000，short r = -20000

- int :  32位、有符号的以二进制补码表示的整数,最小值是 -2,147,483,648（-2^31）,最大值是 2,147,483,647（2^31 - 1）
         例子：int a = 100000, int b = -200000

- long : 64 位、有符号的以二进制补码表示的整数,最小值是 -9,223,372,036,854,775,808（-2^63）,默认值0L
         最大值是 9,223,372,036,854,775,807（2^63 -1）
         例子： long a = 100000L，Long b = -200000L

- float: 单精度、32位、符合IEEE 754标准的浮点数, 在储存大型浮点数组的时候可节省内存空间,默认值是 0.0f
         **浮点数不能用来表示精确的值，如货币**
         例子：float f1 = 234.5f

- double: 双精度、64 位、符合IEEE 754标准的浮点数, 默认值是 0.0d
          **double类型同样不能表示精确的值，如货币**
          例子：double d1 = 123.4

- boolean: 只有两个取值：true 和 false，默认值是 false

- char : char类型是一个单一的 16 位 Unicode 字符, 最小值是 \u0000（即为0）,最大值是 \uffff（即为65,535）
         **char 数据类型可以储存任何字符(只能放单个字符)**，默认值 'u0000'

         因为char是16位的，采取的Unicode的编码方式，所以char就有以下的初始化方式：
         char c = '陈';     //任意单个中文字，加单引号
         char c = 'A';      //任意单个字符，加单引号
         char c = 10;       //可以用整数赋值
         char c = '\u数字'; //用字符的编码值来初始化


         char类型是可以运算的,因为 char 在 ASCII 等字符编码表中有对应的数值
         在 Java 中，对 char 类型字符运行时，直接当做 ASCII 表对应的整数来对待


**byte、int、long、和short都可以用十进制、16进制以及8进制的方式来表示**
int decimal = 100;
int octal = 0144;
int hex =  0x64;


## 位、字节、字符的区别
- 位（bit）： **计算机中最小的存储单位**，1100 1010 是一个八位二进制数
- 字节(byte): **计算机中数据处理的基本单位**，习惯用B表示  1B(byte，字节)=8bit（位）
- 字符：        计算机中使用用的一个字母，数字，字和符号


## byte、char、int 的区别

- byte  是**字节**数据类型 ，是有符号型的，占1 个字节；大小范围为-128—127 
- char  是**字符**数据类型 ，是无符号型的，占2字节(Unicode码 ）；大小范围 是0—65535(对应的 Unicode 码位置)
  char是一个16位二进制的Unicode字符，JAVA用char来表示一个字符
- int 



1. Char是无符号型的，可以表示一个整数，不能表示负数；而byte是有符号型的，可以表示-128—127 的数
2. char可以表中文字符，byte不可以
3. char、byte、int对于英文字符，可以相互转化
4. char 是字符，byte 是字节，都可以强制转换为一个整数。(char 强制转换为整数表示 这个字符对应的  Unicode 码的位置)

   byte a = 'a';   //a对应ASCII是97
   char i = 73;    //I对应ASCII是73
   int j = 'j';    //j对应ASCII是106 


# 二、引用数据类型

- 对象、数组都是引用数据类型。
- 所有引用类型的默认值都是null


# 三、StringBuffer、StringBuilder

当对字符串进行修改的时候，需要使用 StringBuffer 和 StringBuilder 类
和 String 类不同的是，StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象

StringBuilder 和 StringBuffer 之间的最大不同在于 **StringBuilder 的方法不是线程安全的**（不能同步访问）
由于 StringBuilder 相较于 StringBuffer 有速度优势，
所以多数情况下建议使用 StringBuilder 类。然而在应用程序要求线程安全的情况下，则必须使用 StringBuffer 类


# 位运算
http://c.biancheng.net/view/784.html

Java 定义的位运算（bitwise operators）直接对整数类型的位进行操作，这些整数类型包括 byte，short，int，long 和 char

位运算符主要用来对操作数二进制的位进行运算。按位运算表示按每个二进制位（bit）进行计算，其操作数和运算结果都是整型值

Java 语言中的位运算符分为 **位逻辑运算符**和**位移运算符**两类

## 位逻辑运算符

位逻辑运算符包含 4 个，除了 ~（即位取反）为单目运算符外，其余都为双目运算符
- & (与)
- | (或)
- ~ (非)
- ^ (异或)

|运算符|含义|示例|结果|
|:-:|:-:|:-:|:-:|
|  &  | 按位进行与运算（AND）|  4&5  | 4  |
|  |  | 按位进行或运算（OR） |  4|5  | 5  |
|  ^  | 按位进行异或运算（XOR）| 4^5 | 1  |
|  ~  | 按位进行取反运算（NOT）| ~ 4 | -5 |

** & (与,AND)**
参与运算的数字，低位对齐，高位不足的补零，如果对应的二进制位**同时为 1，那么计算结果才为 1，否则为 0**
因此，任何数与 0 进行按位与运算，其结果都为 0

例如：4&5
     0000 0100
 &   0000 0101
 =   0000 0100   -> 4


按位与可以用来屏蔽特定的位，对特定的位清零
也可以用来**取某个数中某些指定的位**，
如：取整数变量i的第五位，可以这样表示int theFifthBit = i & 16 (16=0001 0000)


** | (或,OR) **
参与运算的数字，低位对齐，高位不足的补零。如果对应的二进制位**只要有一个为 1，那么结果就为 1；
如果对应的二进制位都为 0，结果才为 0**

例如：4|5
     0000 0100
 |   0000 0101
 =   0000 0101    -> 5

**按位或和可以将某些位变为1**
如：将整型变量i的第四位和第五位换成1，可以用语句 int setFourthAndFifthBit = i | 24; 来实现（24=0001 1000）

** ~ (非,NOT) **
只对一个操作数进行运算，将操作数二进制中的 **1 改为 0，0 改为 1**

例如：~4
     0000 0101 -> 1111 1010

注意： 取反之后的结果是十六进制数


** ^ (异或,XOR) **
参与运算的数字，低位对齐，高位不足的补零，如果对应的二进制位**相同（同时为 0 或同时为 1）时，结果为 0；
如果对应的二进制位不相同，结果则为 1**

例如：4|5
     0000 0100
 |   0000 0101
 =   0000 0001    -> 1


**注意：位运算符的操作数只能是整型或者字符型数据以及它们的变体，不用于 float、double 或者 long 等复杂的数据类型**


## 位移运算符
位移运算符用来将操作数向某个方向（向左或者右）移动指定的二进制位数

|运算符|含义|示例|结果|
|:-:|:-:|:-:|:-:|
|  >>  | 右移位运算符 |  5>>1  | 4  |
|  <<  | 左移位运算符 |  5<<2  | 20  |

**右移位运算符**
按二进制形式把所有的数字**向右移动对应的位数，低位移出（舍弃），高位的空位补零**

例如：
    5>>1
    0000 0101  ->  0000 0010    =  2

**右移一位相当于除以2取商，而且用右移实现除法比除法速度要快**

**左移位运算符**
按二进制形式把所有的数字**向左移动对应的位数，高位移出（舍弃），低位的空位补零**
例如：
    5<<2
    0000 0101 -> 0001 0100  =  20

**在不产生溢出的情况下，左移1位相当于承2，左移实现乘法比乘法运算速度要快**


## 复合位赋值运算符
所有的二进制位运算符都有一种**将赋值与位运算组合在一起**的简写形式。
复合位赋值运算符由赋值运算符与位逻辑运算符和位移运算符组合而成

|运算符|含义|示例|结果|
|:-:|:-:|:-:|:-:|
|  &=  | 按位与赋值	 |  a&=b  | 等价于 a = a&b  |
|  |=  | 按位或赋值	 |  a|=b  | 等价于 a = a|b  |
|  ^=  | 按位异或赋值 |  a^=b  | 等价于 a = a^b  |
|  ~=  | 按位取反赋值 |  a~=b  | 等价于 a = a~b  |
|  >>= | 按位右移赋值 |  a>>=b | 等价于 a = a>>b |
|  <<= | 按位左移赋值 |  a<<=b | 等价于 a = a<<b |


# 







